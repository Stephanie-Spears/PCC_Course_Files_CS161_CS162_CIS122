<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>Untitled document</title>
</head>
<body>
<p>Overview<br />--------<br /><br />The final chapter for this term covers "Applications of Arrays".&nbsp; This<br />is an introduction to topics that you will learn in detail in the<br />following terms.&nbsp; Because it will be handled in more detail later we<br />will only be highlighting it here.<br /><br />Sequential Searching<br />--------------------<br /><br />The basic idea of a sequential search is to start at the beginning of<br />an array and look at each element one at a time.&nbsp; For example, if I<br />have an array of integers I can do the following to find 17.<br /><br />bool found = false;<br />for (int i=0;i&lt;SIZE;i++) {<br />&nbsp; if (arr[i] == 17) {<br />&nbsp;&nbsp;&nbsp; found = true;<br />&nbsp; }<br />}<br /><br />Notice that I am using a for loop to look at each element one at a<br />time.&nbsp; That is, I'm looking at them in sequence.<br /><br />Sequential searches are simple and effective but they can be slow.&nbsp; If<br />you have a list of 1,000,000 elements it will take, on average,<br />500,000 lookups to find the element.<br /><br />A Faster Search<br />---------------<br /><br />A faster way of searching is the Binary Search.&nbsp; A binary search<br />requires that you start with an ordered lists.&nbsp; Then you look at the<br />middle element of the list.&nbsp; If the target value is less than the<br />middle element, continue searching in the first half.&nbsp; Otherwise<br />continue in the second half.&nbsp; Repeat this until you find the element<br />or run oiut of elements.<br /><br />A binary search is a lot faster than a sequential search.&nbsp; In fact,<br />for 1,000,000 elements, the average number of lookups is 20.<br /><br />Sorting<br />-------<br /><br />In Computer Science the term "sorting" refers to putting things in<br />order.&nbsp; That is, sorting a list of numbers means putting them in<br />ascending or descending order.&nbsp; Just as with searching, there are a<br />number of algorithms available for sorting.&nbsp; Some are slow and some<br />are fast.&nbsp; In this chapter we cover the category of searches known as<br />"n-squared" searches. <br /><br />Bubble Sort<br />-----------<br /><br />The bubble sort is based on a simple principle: compare two adjacent<br />elements.&nbsp; The they are out of order with respect to each other then<br />swap them.&nbsp; Continue doing this until everything is in order.<br /><br />The code looks something like this:<br /><br />for (int i=0; i&lt;len; i++) {<br />&nbsp; for (int j=0; j&lt;len; j++) {<br />&nbsp;&nbsp;&nbsp; if (arr[i] &gt; arr[j]) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swap(arr[i],arr[j]);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />}<br /><br />Selection Sort<br />--------------<br /><br />The basic idea behind the selection sort is to find the smallest<br />element of the list and move it to the front of the list.&nbsp; Then shrink<br />the list by one and repeat.&nbsp; Continue doing this until you read the<br />end of the list.<br /><br />The code looks something like this:<br /><br />for (int i=0; i&lt;len; i++) {<br />&nbsp; int smallest = arr[i];<br />&nbsp; int smallestIdx = i;<br /><br />&nbsp; for (int j=i; j&lt;len; j++) {<br />&nbsp;&nbsp;&nbsp; if (arr[j] &lt; smallest) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smallest = arr[j];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smallestIdx = j;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br /><br />&nbsp; swap(arr[i],arr[smallestIdx]);<br />}<br /><br />It is a bit more complicated than the bubble sort but it is more<br />efficient.&nbsp; The bubble sort will move elements multiple times.&nbsp; The<br />selection sort will move elements around a lot fewer times.<br /><br />Insertion Sort<br />--------------<br /><br />The insertion sort is slightly more complicated.&nbsp; It tries to reduce<br />the number of comparisons even more.&nbsp; Since this one is more<br />complicated it is best to look in the book and see the example there.<br /><br />The n-squared Sorts<br />-------------------<br /><br />All of these sorting algorithms are n-squared.&nbsp; That means that for a<br />list of n elements, it will take approximately n*n operations to sort<br />the list.&nbsp; For example, a list of 1,000 elements will require about<br />1,000,000 operations for sorting.&nbsp; This is not good performance so in<br />general people avoid using the n-squared sorts.&nbsp; There are faster<br />sorts that you will learn about later. &nbsp;<br /><br />However, it's not a total waste to learn about the n-squared sorts.<br />These are very good "training wheels" for learning about the higher<br />level algorithms.</p>
</body>
</html>