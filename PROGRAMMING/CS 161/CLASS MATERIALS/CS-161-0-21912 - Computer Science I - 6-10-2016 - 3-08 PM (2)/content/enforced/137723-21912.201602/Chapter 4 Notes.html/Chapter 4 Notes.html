<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>Untitled document</title>
</head>
<body>
<p>Overview<br />--------<br /><br />The last couple of chapters provided the basics about simple data<br />types, variables, and I/O.&nbsp; Now we are going to start looking at<br />making our programs a little bit more complex.<br /><br />Everything we've done so far with programs has been "straight<br />line". That is, we do the following:<br /><br />task1<br />task2<br />task3<br /><br />Each task is done in order with no variability.&nbsp; This is fine for very<br />simple things (like the BMI calculation) but most problems have<br />conditions in them.&nbsp; For example, "if today is garbage day, then take<br />the garbage out to the curb".&nbsp; We wouldn't want to define a task "take<br />the garbage out to the curb" that took the garbage out without<br />considering the day.&nbsp; Instead, we want to "conditionally" take the<br />garbage out.<br /><br />This idea of selecting the statements that we do based on conditions<br />is what this chapter is about.<br /><br />Relational Operators<br />--------------------<br /><br />To start we will introduce a new kind of operator: the relational<br />operator.<br /><br />Remember that we already have seen arithmetic operators (*,+,-,/,%)<br />and the assignment operator (=) and the input/output operators<br />(&lt;&lt;,&gt;&gt;).&nbsp; Relational operators are used to compare two values.&nbsp; The<br />define the "relationship" between them.<br /><br />There are six relational operators: == != &lt; &lt;= &gt; &gt;=<br /><br />Notice that the equality operator is "==" NOT "=".&nbsp; It is very common<br />to make the mistake of using "=" when you meant to use "==".<br /><br />The result of using a relational operator is a boolean value of true<br />or false.<br /><br />It is important to notice the section on comparing floating point<br />values for equality.&nbsp; Due to precision errors it is error prone to use<br />== with floating point numbers.&nbsp; Instead you should subtract the two<br />numbers to see if they are "close".<br /><br />You can use relationship operators to compare characters.&nbsp; The ASCII<br />values of the characters are compared.<br /><br />Using relational operators results in "logical expressions".&nbsp; For<br />instance:<br /><br />2 &lt; 3<br /><br />is a logical expression.&nbsp; All expressions have a value.&nbsp; The value of<br />this expression is "true". &nbsp;<br /><br />Logical (Boolean) Operators and Logical Expressions<br />---------------------------------------------------<br /><br />Another set of operators is the set of logical operators: &amp;&amp;, ||, !.<br />The logical operators are used to combine logical expressions.<br /><br />&amp;&amp; is "and"<br />|| is "or"<br />! is "not"&nbsp; (note that this is unary)<br /><br />Examples 4-2, 4-3, and 4-4 show various complex logical expressions<br />and their values.&nbsp; You should be able to understand these.<br /><br />Another key point is the concept of "short circuit" evaluation.<br />Consider this logical expression:<br /><br />(4 &gt; 5) || (4 &gt; 6)<br /><br />Notice that there is an "or" with two operands.&nbsp; Due to the<br />parenthesis we need to evaluation each of those other expressions<br />first.&nbsp; After evaluating (4 &gt; 5) to true it is not necessary to<br />evaluate the rest of the expression. Since one part of the "or"<br />operation is true, we already know that the entire expression will be<br />true.&nbsp; Since we don't need to evaluate the second expression, we<br />don't.&nbsp; This is called "short circuiting".&nbsp; Notice that the same thing<br />happens with the "and" operation.<br /><br />Selection: if and if...else<br />---------------------------<br /><br />Now that we understand relational operators and logical expressions we<br />can look at conditional execution of statements.&nbsp; First there is<br />"one-way selection".&nbsp; This is done with the if statement:<br /><br />if (expr)<br />&nbsp; statement<br /><br />For example:<br /><br />if (age &lt; 10)<br />&nbsp; cout &lt;&lt; "You are too young to run this program." &lt;&lt; endl;<br /><br />"two-way selection" is just like "one-way" but with an "else" clause<br />added.<br /><br />if (expr)<br />&nbsp; statement<br />else<br />&nbsp; statement<br /><br />For example:<br /><br />if (gender == "male") <br />&nbsp; title = "Mr.";<br />else<br />&nbsp; title = "Ms.";<br /><br />It is common to do more than one thing in the "statement" controlled<br />by an if.&nbsp; We use block statements for this.&nbsp; The {} symbols define a<br />block:<br /><br />if (gender == "male") <br />{<br />&nbsp; title = "Mr.";<br />&nbsp; averageHeight = 72;<br />}<br />else<br />{<br />&nbsp; title = "Ms.":<br />&nbsp; averageHeight = 68;<br />}<br /><br />Nested if<br />---------<br /><br />It is possible to have the "statement" of an if statement be another<br />if:<br /><br />if (status == "student")<br />{<br />&nbsp; if (balance == 0)<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; cout &lt;&lt; "paid" &lt;&lt; endl;<br />&nbsp; }<br />&nbsp; else<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; cout &lt;&lt; "you owe" &lt;&lt; endl;<br />&nbsp; }<br />}<br /><br />Dangling else<br />-------------<br /><br />A common mistake is the "dangling else" problem.&nbsp; Consider this code:<br /><br />if (balance &lt; 1000)<br />&nbsp; if (balance &gt; 500)<br />&nbsp;&nbsp;&nbsp; cout &lt;&lt; "between 500 and 1000" &lt;&lt; endl;<br />else<br />&nbsp; cout &lt;&lt; "balance greater than 1000" &lt;&lt; endl;<br /><br />What happens when balance is 2000?&nbsp; What about when the balance is 0?<br /><br />The answer is that this program prints "between 500 and 1000" for the<br />first sitution and "balance greater than 1000" for the second.&nbsp; The<br />problem is that the "else" clause can go with either if statement.<br />The rule in C++ is that the else goes with the closest if.&nbsp; So in C++<br />this becomes:<br /><br />if (balance &lt; 1000)<br />&nbsp; if (balance &gt; 500)<br />&nbsp;&nbsp;&nbsp; cout &lt;&lt; "between 500 and 1000" &lt;&lt; endl;<br />&nbsp; else<br />&nbsp;&nbsp;&nbsp; cout &lt;&lt; "balance greater than 1000" &lt;&lt; endl;<br /><br />Since that's not what you wanted you have to use {} to fix it:<br /><br />if (balance &lt; 1000)<br />{<br />&nbsp; if (balance &gt; 500)<br />&nbsp;&nbsp;&nbsp; cout &lt;&lt; "between 500 and 1000" &lt;&lt; endl;<br />}<br />else<br />{<br />&nbsp; cout &lt;&lt; "balance greater than 1000" &lt;&lt; endl;<br />}<br /><br />It is a good habit to just always use {}.<br /><br />Input Failure and the if Statement<br />----------------------------------<br /><br />We now have the ability to be more robust with our input.&nbsp; Using an if<br />statement we can check to make sure that cin is not in a failure<br />state.&nbsp; If it is then we'll use cin.ignore() and cin.clear (last<br />chapter) to get back to a good state.<br /><br />Selection: switch<br />-----------------<br /><br />The switch statement makes multi-way switching easier.&nbsp; The general<br />syntax is:<br /><br />switch (expr) {<br />&nbsp; case value1:<br />&nbsp;&nbsp;&nbsp; statements1;<br />&nbsp;&nbsp;&nbsp; break;<br />&nbsp; case value2:<br />&nbsp;&nbsp;&nbsp; statements2;<br />&nbsp;&nbsp;&nbsp; break;<br />&nbsp; ...<br />&nbsp; default:<br />&nbsp;&nbsp;&nbsp; statements<br />}<br /><br />A couple of important notes on this.&nbsp; Without the "break" the<br />statements will fall through to the next case.&nbsp; This is intentional<br />but could be the source of errors in your program. &nbsp;<br /><br />The default statements will only execute if none of the cases match.<br /><br />The "expr" for a switch statement can only be an integral value.&nbsp; It<br />CANNOT be a string.&nbsp; If you want switch like behavior with strings you<br />have to do it with nested if statements.</p>
</body>
</html>