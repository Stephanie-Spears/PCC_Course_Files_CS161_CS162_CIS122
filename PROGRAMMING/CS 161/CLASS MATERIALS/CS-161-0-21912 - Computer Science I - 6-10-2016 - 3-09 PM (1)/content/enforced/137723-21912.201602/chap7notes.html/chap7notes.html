<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>Untitled document</title>
</head>
<body>
<p>Overview<br />--------<br /><br />Last week we started talking about user-defined functions.&nbsp; This week<br />we wil go into a lot more detail for these. <br /><br />Void Functions<br />--------------<br /><br />"void" functions are functions that do not return a value.&nbsp; In the<br />function declaration (prototype or heading) the keyword "void" is<br />specified for the return type.&nbsp; For example:<br /><br />void printSplashScreen();<br /><br />Void functions are often used to print data.&nbsp; Example 7-1 shows a use<br />of a void function to print two rows of * charactes.<br /><br />Even though a void function doesn't have a return type, it can still<br />take parameters.&nbsp; The "void" part of a function refers only to the<br />return type, not to the parameters.<br /><br />Value Parameters<br />----------------<br /><br />There are two types of parameters: value and reference.&nbsp; It is very<br />important to keep track of these differences.&nbsp; A function using a<br />value parameter receives a _copy_ of the actual parameter that was<br />passed.<br /><br />This means that if the value is changes in the function, it is<br />changing a copy, not the actual variable.<br /><br />Consider this:<br /><br />void incr(int x) {<br />&nbsp; x++;<br />}<br /><br />int main() {<br />&nbsp; int y=10;<br />&nbsp; cout &lt;&lt; y &lt;&lt; endl;<br />&nbsp; incr(y);<br />&nbsp; cout &lt;&lt; y &lt;&lt; endl;<br />}<br /><br />In this case the value "10" would be printed twice. &nbsp;<br /><br />Reference Variables as Parameters<br />---------------------------------<br /><br />Reference variables can be changed in the function.&nbsp; Consider the same<br />case as above but with a reference parameter:<br /><br />void incr(int&amp; x) {<br />&nbsp; x++;<br />}<br /><br />int main() {<br />&nbsp; int y=10;<br />&nbsp; cout &lt;&lt; y &lt;&lt; endl;<br />&nbsp; incr(y);<br />&nbsp; cout &lt;&lt; y &lt;&lt; endl;<br />}<br /><br />In this case the values "10" and "11" are printed.&nbsp; It is important to<br />understand the difference between value and reference parameters<br /><br />Value and Reference Parameters and Memory Allocation<br />----------------------------------------------------<br /><br />This section is important to understand.&nbsp; The explanation in the book<br />is good and complete.&nbsp; Pay special attention to how and when memory is<br />allocated for variables during parameter passing.<br /><br />Scope of an Identifier<br />----------------------<br /><br />The main point to understand about variable scope is this:<br /><br />When variables are declared within a block, they are only visible<br />within that block.&nbsp; For the most part we create variables inside of<br />functions.&nbsp; These variables, then, are only available from within that<br />function. <br /><br />The book goes into more detail about the scope resolution operator and<br />extern variables.&nbsp; Those aspects of C++ are not so important right<br />now.&nbsp; If you find it interesting to read about that's fine but you<br />don't need to fully understand it.<br /><br />Global Variables, Named Constants, and Side Effects<br />---------------------------------------------------<br /><br />Rule #1: Global variables are BAD!!!!<br />Rule #2: Global variables are VERY BAD!!!!<br /><br />Back in the old days early software engineers were coming from a very<br />low level perspective on computer programming.&nbsp; They were dealing with<br />assembly language and then trying to move to a higher level<br />programming language like C or C++.&nbsp; Assembly language does not have<br />all of the same sorts of constructs like C or C++.&nbsp; It is completely<br />different programming.&nbsp; The issues there are all different.&nbsp; But some<br />of the ideas and ways of doing things carried forward.&nbsp; Global<br />variables is one of those things.<br /><br />If the people who designed C/C++ did not originally start with<br />assembly language programming I doubt that we would even have global<br />variables like we do now.<br /><br />There are a few places where globals are needed (e.g. embedded system<br />code) but for the vast majority of the time they can be (and should<br />be) completely avoided.<br /><br />Function Overloading: An Introduction<br />-------------------------------------<br /><br />Function overloading is very handy.&nbsp; Basically, it is having mulitple<br />functions with the same name.&nbsp; The functions are distinguished by<br />having different parameter lists.<br /><br />Note that functions cannot overload based on return type.&nbsp; That is not<br />allowed in C++.<br /><br />Functions with Default Parameters<br />---------------------------------<br /><br />Default parameters are interesting but not critical.&nbsp; Since there is<br />already so much in this chapter I'm not going to focus a lot on this.</p>
</body>
</html>